<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Elliptic SPD Tube (Three.js)</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js"
            }
        }
    </script>
    <style>
        @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap");

        :root {
            --bg: #f5f7fb;
            --panel: #0f172a;
            --text: #0b1021;
            --accent: #2dd4bf;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            display: grid;
            grid-template-columns: 1.4fr 0.6fr;
            height: 100vh;
            font-family: "Space Grotesk", "Helvetica Neue", Arial, sans-serif;
            color: var(--text);
        }

        .view {
            position: relative;
            width: 100%;
            height: 100%;
            background: #ffffff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        }

        .label {
            position: absolute;
            top: 12px;
            left: 12px;
            padding: 6px 10px;
            background: rgba(15, 23, 42, 0.82);
            color: #fff;
            font-size: 30px;
            border-radius: 6px;
            letter-spacing: 0.01em;
        }

        .mini-views {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 10px;
            z-index: 2;
        }

        .mini-view {
            position: relative;
            width: 280px;
            height: 240px;
            border-radius: 12px;
            overflow: hidden;
            background: #f8fafc;
            box-shadow: 0 10px 20px rgba(15, 23, 42, 0.18);
            border: 1px solid rgba(15, 23, 42, 0.08);
        }

        .mini-label {
            position: absolute;
            top: 6px;
            left: 8px;
            padding: 4px 8px;
            background: rgba(15, 23, 42, 0.75);
            color: #fff;
            font-size: 11px;
            border-radius: 999px;
            letter-spacing: 0.02em;
        }

        /* Right side panel */
        #panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 18px;
            padding: 24px 5px;
            background: #ffffff;
            color: var(--text);
            box-shadow: inset 0 1px 0 rgba(0, 0, 0, 0.02), 0 10px 30px rgba(0, 0, 0, 0.06);
        }

        #panel h2 {
            margin: 0;
            font-size: 40px;
            letter-spacing: 0.02em;
            text-align: center;
        }

        #panel .sub {
            font-size: 20px;
            opacity: 0.7;
            margin-top: -6px;
        }

        .colorbar-wrap {
            position: relative;
            width: 80px;
            height: 320px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #colorbar {
            width: 80px;
            height: 320px;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.18);
            border: 1px solid rgba(0, 0, 0, 0.04);
        }

        #z-slider {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            margin: 0;
        }

        #z-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: var(--accent);
            border: 2px solid #0f172a;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.25);
        }

        #z-slider::-moz-range-thumb {
            background: var(--accent);
            border: 2px solid #0f172a;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            box-shadow: 0 0 0 3px rgba(45, 212, 191, 0.25);
        }

        #z-value {
            font-size: 40px;
            letter-spacing: 0.02em;
            color: #475569;
        }

        #play-toggle {
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: rgba(45, 212, 191, 0.1);
            color: #0b1021;
            cursor: pointer;
            font-size: 13px;
            letter-spacing: 0.02em;
            transition: transform 120ms ease, background 120ms ease, border 120ms ease;
        }

        #play-toggle:hover {
            transform: translateY(-1px);
            background: rgba(45, 212, 191, 0.22);
            border-color: rgba(0, 0, 0, 0.2);
        }
    </style>
</head>

<body>
    <div id="view-3d" class="view">
        <div class="label">2x2 SPD Matrices as Covariate Varies</div>
        <div class="mini-views">
            <div id="view-top" class="mini-view">
                <div class="mini-label">Top view</div>
            </div>
            <div id="view-side" class="mini-view">
                <div class="mini-label">Side view</div>
            </div>
        </div>
    </div>
    <div id="panel">
        <h2>Covariate Values <br> (z-axis)</h2>
        <div class="colorbar-wrap">
            <canvas id="colorbar" width="80" height="320"></canvas>
            <input id="z-slider" type="range" min="0" max="2" step="0.01" value="0" aria-label="z level">
        </div>
        <div id="z-value">z = 0.00</div>
        <button id="play-toggle" type="button">Animate</button>
    </div>
    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";

        // ----- Basic scene setup -----
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
        camera.position.set(2, -9, 5);
        camera.lookAt(0, 0, 0);

        const container3d = document.getElementById("view-3d");
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        container3d.appendChild(renderer.domElement);

        const containerTop = document.getElementById("view-top");
        const topRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        topRenderer.setPixelRatio(window.devicePixelRatio);
        containerTop.appendChild(topRenderer.domElement);

        const containerSide = document.getElementById("view-side");
        const sideRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        sideRenderer.setPixelRatio(window.devicePixelRatio);
        containerSide.appendChild(sideRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 1);
        controls.update();

        const topCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
        topCamera.position.set(0, 0, 10);
        topCamera.up.set(0, 1, 0);
        topCamera.lookAt(0, 0, 0);

        const sideCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
        sideCamera.position.set(0, 10, 0);
        sideCamera.up.set(0, 0, 1);
        sideCamera.lookAt(0, 0, 0);

        // Axes helper (optional)
        const axesHelper = new THREE.AxesHelper(3);
        scene.add(axesHelper);

        // Lights
        const light1 = new THREE.DirectionalLight(0xffffff, 1.05);
        light1.position.set(5, 10, 7);
        scene.add(light1);

        const light2 = new THREE.AmbientLight(0xffffff, 0.45);
        scene.add(light2);

        // ----- Surface parameters (same math as your manim version) -----
        const zMin = 0.0;
        const zMax = 2.0;   // we will grow up to this
        const c = 1.0;

        const radialSegments = 128;  // in theta
        const heightSegments = 64;   // in "alpha" (0..1 mapped to z)

        const vertexCount = (radialSegments + 1) * (heightSegments + 1);
        const positions = new Float32Array(vertexCount * 3);
        const colors = new Float32Array(vertexCount * 3);

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        // Build index buffer for triangles
        const indices = [];
        for (let i = 0; i < heightSegments; i++) {
            for (let j = 0; j < radialSegments; j++) {
                const a = i * (radialSegments + 1) + j;
                const b = (i + 1) * (radialSegments + 1) + j;
                const cIdx = (i + 1) * (radialSegments + 1) + (j + 1);
                const d = i * (radialSegments + 1) + (j + 1);
                // Two triangles (a,b,d) and (b,cIdx,d)
                indices.push(a, b, d, b, cIdx, d);
            }
        }
        geometry.setIndex(indices);

        const material = new THREE.MeshPhongMaterial({
            side: THREE.DoubleSide,
            vertexColors: true,
            shininess: 60
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // ----- Update geometry for a given top z -----
        function colorFromT(tColor) {
            const color = new THREE.Color();
            color.setHSL(0.66 * (1 - tColor), 1.0, 0.5);
            return color;
        }

        function updateGeometry(zTop) {
            let p = 0;
            let cptr = 0;

            for (let i = 0; i <= heightSegments; i++) {
                const alpha = i / heightSegments;                // 0..1
                const z = zMin + alpha * (zTop - zMin);          // z in [zMin, zTop]

                // a(z) = c * exp(z/2), b(z) = c * exp(1)
                const a = c * Math.exp(z / 2.0);
                const b = c * Math.exp(1.0);

                const tColor = (z - zMin) / (zMax - zMin);       // 0..1
                const color = colorFromT(tColor);               // hue from blue to warm

                for (let j = 0; j <= radialSegments; j++) {
                    const theta = (j / radialSegments) * Math.PI * 2.0;

                    const x = a * Math.cos(theta);
                    const y = b * Math.sin(theta);

                    positions[p++] = x;
                    positions[p++] = y;
                    positions[p++] = z;

                    colors[cptr++] = color.r;
                    colors[cptr++] = color.g;
                    colors[cptr++] = color.b;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        // Initialize geometry at zTop ~ 0
        updateGeometry(zMin + 1e-3);

        // ----- UI: colorbar + slider -----
        const slider = document.getElementById("z-slider");
        const zValue = document.getElementById("z-value");
        const colorbar = document.getElementById("colorbar");
        const playToggle = document.getElementById("play-toggle");

        function drawColorbar() {
            const ctx = colorbar.getContext("2d");
            const w = colorbar.width;
            const h = colorbar.height;
            const image = ctx.createImageData(w, h);
            for (let y = 0; y < h; y++) {
                const t = 1 - y / (h - 1); // top = zMax
                const color = colorFromT(t);
                const r = Math.round(color.r * 255);
                const g = Math.round(color.g * 255);
                const b = Math.round(color.b * 255);
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    image.data[idx] = r;
                    image.data[idx + 1] = g;
                    image.data[idx + 2] = b;
                    image.data[idx + 3] = 255;
                }
            }
            ctx.putImageData(image, 0, 0);
        }
        drawColorbar();

        function setZValue(zTop) {
            zValue.textContent = `z = ${zTop.toFixed(2)}`;
            slider.value = zTop.toFixed(2);
        }

        setZValue(zMin);

        // Animation controls
        let startTime = performance.now();
        const duration = 25000; // ms
        let autoPlay = true;

        function animate() {
            requestAnimationFrame(animate);
            let zTop = parseFloat(slider.value);

            controls.update();

            if (autoPlay) {
                const elapsed = performance.now() - startTime;
                const t = Math.min(elapsed / duration, 1.0);        // 0..1
                zTop = zMin + t * (zMax - zMin);
                setZValue(zTop);
                slider.value = zTop;
            }

            updateGeometry(zTop);
            renderer.render(scene, camera);
            topRenderer.render(scene, topCamera);
            sideRenderer.render(scene, sideCamera);
        }

        animate();


        controls.addEventListener('change', () => {
            console.log('Camera position changed:', camera.position);
            // You could also log world position here if needed
            const worldPos = new THREE.Vector3();
            camera.getWorldPosition(worldPos);
            console.log('Camera world position changed:', worldPos);
        });


        // Manual slider interaction pauses autoplay
        slider.addEventListener("input", (e) => {
            autoPlay = false;
            const zTop = parseFloat(e.target.value);
            setZValue(zTop);
            updateGeometry(zTop);
            renderer.render(scene, camera);
            topRenderer.render(scene, topCamera);
            sideRenderer.render(scene, sideCamera);
        });

        playToggle.addEventListener("click", () => {
            autoPlay = !autoPlay;
            if (autoPlay) {
                // restart timeline from current slider position
                const currentZ = parseFloat(slider.value);
                const t = (currentZ - zMin) / (zMax - zMin);
                startTime = performance.now() - t * duration;
                playToggle.textContent = "Pause animation";
            } else {
                playToggle.textContent = "Play animation";
            }
        });

        // Handle resize
        function resize() {
            const width = container3d.clientWidth;
            const height = container3d.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            const topWidth = containerTop.clientWidth;
            const topHeight = containerTop.clientHeight;
            topCamera.aspect = topWidth / topHeight;
            topCamera.updateProjectionMatrix();
            topRenderer.setSize(topWidth, topHeight);

            const sideWidth = containerSide.clientWidth;
            const sideHeight = containerSide.clientHeight;
            sideCamera.aspect = sideWidth / sideHeight;
            sideCamera.updateProjectionMatrix();
            sideRenderer.setSize(sideWidth, sideHeight);
        }

        window.addEventListener("resize", resize);
        resize();
    </script>
</body>

</html>